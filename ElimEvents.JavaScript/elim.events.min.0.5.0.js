/* @license
 * ElimSignals <https://github.com/TolanNightBlade/ElimEvents.JavaScript/>
 * Released under the MIT license
 * Author: Michael Wood
 * Version: 0.5.0 (2013/06/13 14:45)
*/
!function (t) { "use strict"; function n(t, n) { this._cb = !1, this.context = null, this.target = null, this.data = n, this.value = null, this.name = t } function e(t, n, e) { this.cb = t, this.isOnce = n, this.context = e } function i(t, n, e) { this.name = null, this.context = e, this.listeners = [], this.active = !0, this.lastEvent = null, this.hasRun = !1, this.memorise = !0, this.name = t, n && (this.memorise = n.memorise, this.active = n.active) } function s(t, n) { (null === n || void 0 === n) && (n = {}), this.handlers = [], this.context = t || this, this.memorise = "boolean" == typeof n.memorise ? n.memorise : !0 } var r = Array.prototype.slice; n.prototype = { isBubleCancelled: function () { return this._cb }, cancelBubble: function () { this._cb = !0 } }, e.prototype = { destroy: function () { this.cb = null, this.context = null } }, i.prototype = { constructor: i, add: function (t, n, i) { var s; return -1 === this.findIndex(t, i) && (s = new e(t, n, i || this.context), this.listeners.push(s), this.memorise && this.hasRun && s.cb.apply(i || this.lastEvent.context, [this.lastEvent].concat(this.lastEvent.data))), this }, remove: function (t, n) { var e = this.findIndex(t, n); null !== e && -1 !== e && (this.listeners[e].destroy(), this.listeners.splice(e, 1)) }, count: function () { return this.listeners.length }, find: function (t, n, e) { for (var i, s = 0, r = this.listeners.length; r > s; s += 1) if (i = this.listeners[s], i.cb === t && i.context === n) return e ? s : i; return e ? -1 : null }, findIndex: function (t, n) { return this.find(t, n, !0) }, execute: function () { if (this.active !== !1) { var t, e, i = this.listeners.slice(), s = 0, r = i.length, o = arguments[0] || this.context, l = arguments[2] || [], h = new n(this.name, l); for (h.target = arguments[1] || o, h.context = o; r > s && (e = i[s], t = e.cb.apply(e.context || o, [h].concat(l)), e.isOnce && this.listeners.splice(s, 1), t !== !1 && !h.isBubleCancelled()) ; s += 1); return this.hasRun = !0, this.lastEvent = h, h } }, destroy: function () { this.listeners.length = 0, this.name = null, this.listeners = null, this.context = null } }, s.prototype = { setContext: function (t) { this.context = t }, setEnabled: function (t, n) { var e = this.getHandler(t); if (null === e) throw new Error("No handler with the name {name} could be found.".replace("{name}", t)); return e.active = n(), this }, isEnabled: function (t) { var n = this.getHandler(t); return null === n ? null : n.active }, getHandler: function (t) { for (var n = 0, e = this.handlers.length; e > n; n += 1) if (this.handlers[n].name === t) return this.handlers[n]; return null }, setHandler: function (t, n) { var e = new i(t, { memorise: this.memorise, active: !0 }, n || this.context); return this.handlers.push(e), e }, _trigger: function (t, n, e, i) { var s = this.getHandler(t); if (s) return s.execute(e || this.context, n, i) }, trigger: function (t, n) { return this._trigger(t, null, n, r.call(arguments, 2)) }, triggerWithTarget: function (t, n, e) { return this._trigger(t, n, e, r.call(arguments, 3)) }, _on: function (t, n, e, i) { var s = this.getHandler(t), r = i || this.context; if ("function" != typeof n) throw new Error("Unable to register callback, typeof of cb is not a function."); return s || (s = this.setHandler(t, r)), s.add(n, e, i || this.context), s }, on: function (t, n, e, i) { for (var s = t.split(" "), r = 0, o = s.length, l = []; o > r; r += 1) l.push(this._on(s[r], n, e, i || this.context)); return 1 === o ? l[0] : l }, _off: function (t, n, e) { var i = this.getHandler(t); i && i.remove(n, e || this.context) }, off: function (t, n, e) { for (var i = t.split(" "), s = 0, r = i.length, o = []; r > s; s += 1) o.push(this._off(i[s], n, e)); return this }, destroy: function () { this.handlers.length = 0, this.handlers = null, this.context = null } }, t.ElimSignals = s, t.ElimSignals.util = { createOn: function (t) { var n; s.apply(t, [arguments[1]]); for (n in s.prototype) s.prototype.hasOwnProperty(n) && (t[n] = s.prototype[n]) } } }(this);
